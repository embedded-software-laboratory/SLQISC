 
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module SUBLEQ(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS
);

//=======================================================
//  REG/WIRE declarations
//=======================================================
reg     [4:0]   state           = 0;
reg     [4:0]   next_state      = 0;

wire   [21:0]   address;
wire            reset;

wire            write_finished;
wire            read_finished;
wire  [127:0]   write_data;
wire  [127:0]   read_data;

wire            d_key1;
wire            trigger_in;
wire            debug;
reg             in_ready;

reg             write_request;
reg             read_request;

reg   [15:0] pc = 0;
reg   [15:0] next_pc = 0;
reg   [15:0] old_pc = 0;
reg   [15:0] addr = 0;
reg   [15:0] data_write_reg = 0;

wire   [15:0]   romOut;

reg   [15:0] op0 = 0;
reg   [15:0] op1 = 0;
reg   [15:0] op2 = 0;
reg   [15:0] calc = 0;

reg   [15:0] last_out = 0;
reg          triggerOutput = 0;

reg   [47:0] last_instr = 0;
reg   [31:0] last_ref = 0;

wire  clk_25;

wire [3:0] imgr;
wire [3:0] imgg;
wire [3:0] imgb;	
wire imghs;
wire imgvs;

wire [3:0] lcdr;
wire [3:0] lcdg;
wire [3:0] lcdb;	
wire lcdhs;
wire lcdvs;

assign VGA_B = SW[8]  ? imgb  : lcdb;
assign VGA_G = SW[8]  ? imgg  : lcdg;
assign VGA_HS = SW[8] ? imghs : lcdhs;
assign VGA_R = SW[8]  ? imgr  : lcdr;
assign VGA_VS = SW[8] ? imgvs : lcdvs;

assign debug = SW[8] ? SW[9] : 1'b0;

function [7:0] hex_digit(input [3:0] val, input dot);
  begin
    case(val)
	 0: hex_digit = 8'b11000000 & ~(dot << 7);
	 1: hex_digit = 8'b11111001 & ~(dot << 7);
	 2: hex_digit = 8'b10100100 & ~(dot << 7);
	 3: hex_digit = 8'b10110000 & ~(dot << 7);
	 4: hex_digit = 8'b10011001 & ~(dot << 7);
	 5: hex_digit = 8'b10010010 & ~(dot << 7);
	 6: hex_digit = 8'b10000010 & ~(dot << 7);
	 7: hex_digit = 8'b11111000 & ~(dot << 7);
	 8: hex_digit = 8'b10000000 & ~(dot << 7);
	 9: hex_digit = 8'b10010000 & ~(dot << 7);
	 10: hex_digit = 8'b10001000 & ~(dot << 7);
	 11: hex_digit = 8'b10000011 & ~(dot << 7);
	 12: hex_digit = 8'b11000110 & ~(dot << 7);
	 13: hex_digit = 8'b10100001 & ~(dot << 7);
	 14: hex_digit = 8'b10000110 & ~(dot << 7);
	 15: hex_digit = 8'b10001110 & ~(dot << 7);
	 endcase
  end
endfunction

//=======================================================
//  Structural coding
//=======================================================
assign  write_data      = {112'b0, data_write_reg};
assign  HEX0            = hex_digit(last_out[3:0],0);
assign  HEX1            = hex_digit(last_out[7:4],0);
assign  HEX2            = hex_digit(last_out[11:8],0);
assign  HEX3            = hex_digit(last_out[15:12],0);
assign  HEX4            = hex_digit(SW[3:0],1);
assign  HEX5            = hex_digit(SW[7:4],0);
assign  LEDR            = pc[9:0];

assign  address         = {6'b0,addr};

always @(next_pc or next_state or reset) begin
  if (reset)
  begin
    pc = 0;
    state = 0;
  end
  else
  begin
    pc = next_pc;
    state = next_state;
  end
end

localparam SIZE = 16'hffff;

always @(posedge MAX10_CLK1_50)
begin
    if (trigger_in)
	   in_ready <= 1;
    case (state)
	 0:
	 begin
		 addr <= pc;
		 write_request <= 0;
		 read_request <= 0;
		 next_pc <= pc + 16'd1;
	    next_state <= 20;
	 end
	 20:
	 begin
		 data_write_reg <= romOut;
	    next_state <= 1;
	 end
	 1:
	 begin
		 addr <= addr;
		 write_request <= 1;
		 read_request <= 0;
		 next_pc <= pc;
		 if(write_finished && pc == SIZE)
			next_state <= 2;
		 else if(write_finished)
			next_state <= 0;
		 else
			next_state <= 1;
	 end
	 2:
	 begin
		addr <= 0;
		write_request <= 0;
		read_request <= 0;
		next_pc <= 0;
		next_state <= 23;
	 end
	 23: // Set up for reading Op-1 (bizarre workaround)
	 begin
		addr <= 16'hffff;
		write_request <= 0;
		read_request <= 0;
		next_pc <= pc;
		next_state <= 24;
		triggerOutput <= 0;
	 end
	 24: // Read Op-1
	 begin
		addr <= addr;
		write_request <= 0;
		read_request <= 1;
		next_pc <= pc;
		if (read_finished)
		begin
		  next_state <= 3;
		end else begin
		  next_state <= 24;
		end
	 end
	 3: // Set up for reading Op0
	 begin
		addr <= pc;
		write_request <= 0;
		read_request <= 0;
		next_pc <= pc;
		next_state <= 4;
	 end
	 4: // Read Op0
	 begin
		addr <= addr;
		write_request <= 0;
		read_request <= 1;
		next_pc <= pc;
		if (read_finished)
		begin
		  op0 <= read_data[15:0];
		  next_state <= 5;
		end else begin
		  next_state <= 4;
		end
	 end
	 5: // Set up for reading Op1
	 begin
		addr <= pc + 16'd1;
		write_request <= 0;
		read_request <= 0;
		next_pc <= pc;
		next_state <= 6;
	 end
	 6: // Read Op1
	 begin
		addr <= addr;
		write_request <= 0;
		read_request <= 1;
		next_pc <= pc;
		if (read_finished)
		begin
		  op1 <= read_data[15:0];
		  next_state <= 7;
		end else begin
		  next_state <= 6;
		end
	 end
	 7: // Set up for reading Op2
	 begin
		addr <= pc + 16'd2;
		write_request <= 0;
		read_request <= 0;
		next_pc <= pc;
		next_state <= 8;
	 end
	 8: // Read Op2
	 begin
		addr <= addr;
		write_request <= 0;
		read_request <= 1;
		next_pc <= pc;
		if (read_finished)
		begin
		  op2 <= read_data[15:0];
		  next_state <= 9;
		end else begin
		  next_state <= 8;
		end
	 end
	 9: // Set up for reading @Op0
	 begin
		addr <= op0;
		write_request <= 0;
		read_request <= 0;
		next_pc <= pc;
		next_state <= 10;
		last_instr <= {op0,op1,op2};
	 end
	 10: // Read @Op0
	 begin
		addr <= addr;
		write_request <= 0;
		read_request <= 1;
		next_pc <= pc;
		if (read_finished)
		begin
		  calc <= read_data[15:0];
		  last_ref[31:16] <= read_data[15:0];
		  next_state <= 11;
		end else begin
		  next_state <= 10;
		end
	 end
	 11: // Set up for reading @Op1, perform output
	 begin
		addr <= op1;
		write_request <= 0;
		read_request <= 0;
		next_pc <= pc;
		next_state <= 12;
		if (op1 == 16'hffff) begin
		  last_out <= calc;
		end
	 end
	 12: // Read @Op1
	 begin
		addr <= addr;
		write_request <= 0;
		read_request <= 1;
		next_pc <= pc;
		if (op1 == 16'hffff) begin
		  triggerOutput <= 1;
		end
		if (read_finished)
		begin
		  calc <= read_data[15:0] - calc;
		  last_ref[15:0] <= read_data[15:0];
		  next_state <= 13;
		end else begin
		  next_state <= 12;
		end
	 end
	 13: // Set up for writing @Op1
	 begin
		addr <= op1;
		data_write_reg <= calc;
		write_request <= 0;
		read_request <= 0;
		old_pc <= pc;
		if (calc[15] == 1'b1 || calc == 0)
		  next_pc <= op2;
		else
		  next_pc <= pc+16'd3;
		next_state <= 14;
	 end
	 14: // Write @Op1
	 begin
		addr <= addr;
		write_request <= 1;
		read_request <= 0;
		next_pc <= pc;
		if (write_finished && debug) begin
		  next_state <= 17;
		end else if (write_finished && in_ready) begin
		  next_state <= 15;
		end else if (write_finished) begin
		  next_state <= 23;
		end else begin
		  next_state <= 14;
		end
	 end
	 15: // Set up for writing Input
	 begin
		addr <= 16'hfffe;
		data_write_reg <= {8'hff,~SW[7:0]}+16'h1;
		write_request <= 0;
		read_request <= 0;
		in_ready <= 0;
		next_pc <= pc;
		next_state <= 16;
	 end
	 16: // Write Input
	 begin
		addr <= addr;
		write_request <= 1;
		read_request <= 0;
		next_pc <= pc;
		if (write_finished) begin
		  next_state <= 23;
		end else begin
		  next_state <= 16;
		end
	 end
	 17: // Halt State
	 begin
		addr <= addr;
		data_write_reg <= data_write_reg;
		write_request <= 0;
		read_request <= 0;
	   next_pc <= pc;
		if (debug && !trigger_in)
			next_state <= 17;
		else
			next_state <= 23;
	 end
	 default:
	 begin
		addr <= addr;
		data_write_reg <= data_write_reg;
		write_request <= 0;
		read_request <= 0;
	   next_pc <= pc;
      next_state <= 17;
	 end
	 endcase
end



sdram_controller sdram_controller(
	 .iclk(MAX10_CLK1_50),
    .ireset(reset),
    
    .iwrite_req(write_request),
    .iwrite_address(address),
    .iwrite_data(write_data),
    .owrite_ack(write_finished),
    
    .iread_req(read_request),
    .iread_address(address),
    .oread_data(read_data),
    .oread_ack(read_finished),
    
	 //////////// SDRAM //////////
	 .DRAM_ADDR(DRAM_ADDR),
    .DRAM_BA(DRAM_BA),
    .DRAM_CAS_N(DRAM_CAS_N),
    .DRAM_CKE(DRAM_CKE),
    .DRAM_CLK(DRAM_CLK),
    .DRAM_CS_N(DRAM_CS_N),
    .DRAM_DQ(DRAM_DQ),
    .DRAM_LDQM(DRAM_LDQM),
    .DRAM_RAS_N(DRAM_RAS_N),
    .DRAM_UDQM(DRAM_UDQM),
    .DRAM_WE_N(DRAM_WE_N)
);

edge_det edge_det(
    .clk(MAX10_CLK1_50),
	 .sig(d_key1),
	 .edg(trigger_in)
);

pll pll(
    .inclk0(MAX10_CLK2_50),
    .c1(clk_25)
);

vga_lcd vga_lcd(
  .clk_25(clk_25),
  .clk_50(MAX10_CLK1_50),
  .inval(SW[7:0]),
  .pcval(old_pc),
  .addInput(triggerOutput),
  .charCode(last_out[6:0]),
  .reset(reset),
  .instr(last_instr),
  .refs(last_ref),
  .debug(debug),
  .VGA_R(lcdr),
  .VGA_G(lcdg),
  .VGA_B(lcdb),
  .VGA_HS(lcdhs),
  .VGA_VS(lcdvs)
);

vga_img vga_img(
  .clk_25(clk_25),
  .clk_50(MAX10_CLK1_50),
  .addInput(triggerOutput),
  .rgbCode(last_out[11:0]),
  .reset(reset),
  .VGA_R(imgr),
  .VGA_G(imgg),
  .VGA_B(imgb),
  .VGA_HS(imghs),
  .VGA_VS(imgvs)
);

program_rom program_rom(
  .clk(MAX10_CLK1_50),
  .address(pc),
  .instruction(romOut)
);

debounce reset_debounce(
  .clk(MAX10_CLK1_50),
  .sig(~KEY[0]),
  .d_sig(reset)
);

debounce input_debounce(
  .clk(MAX10_CLK1_50),
  .sig(~KEY[1]),
  .d_sig(d_key1)
);

endmodule
